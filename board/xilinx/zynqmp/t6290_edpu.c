#include <common.h>
#include <command.h>
#include <dm.h>
#include <errno.h>
#include <spi.h>
#include <i2c.h>

#include "t6290_edpu.h"

#include <rtk_switch.h>

#include <miiphy.h>
#include <phy.h>
#include <port.h>
#include <rtl8367c_asicdrv_port.h>

uint8_t config_dsp1_arr[]=
{
  0xaa, 0x55, 0xaa, 0xff, 0xff, 0xff, 0x07, 0x43, 
  0x00, 0x00, 0xff, 0xff, 0xff, 0x01, 0x86, 0x06, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 
  0xf2, 0x80, 0x10, 0x00, 0x00, 0x00, 0x01, 0xff, 
  0xf2, 0x00, 0x00, 0x00, 0x40, 0x00, 0xbf, 0xff, 
  0xf2, 0x01, 0x04, 0x00, 0x44, 0x01, 0x04, 0xff, 
  0xf2, 0x01, 0x08, 0x98, 0x91, 0x0a, 0x55, 0xff, 
  0xf2, 0x01, 0x0c, 0x0f, 0xb8, 0xa9, 0x1e, 0xff, 
  0xf2, 0x01, 0x00, 0x01, 0x0c, 0x10, 0x00, 0xff, 
  0xf2, 0x01, 0x60, 0x00, 0x00, 0x00, 0x01, 0xff, 
  0xf2, 0x01, 0x64, 0x03, 0x40, 0x14, 0x00, 0xff, 
  0xf2, 0x01, 0x14, 0x24, 0x40, 0x10, 0x00, 0xff, 
  0xf2, 0x01, 0x24, 0x14, 0x50, 0x00, 0x00, 0xff, 
  0xf2, 0x00, 0x80, 0x80, 0x01, 0x43, 0x02, 0xff, 
  0xf2, 0x01, 0x30, 0x02, 0x00, 0x00, 0x00, 0xff, 
  0xf2, 0x01, 0x70, 0x89, 0x08, 0x06, 0x00, 0xff, 
  0xf2, 0x01, 0x74, 0x86, 0x45, 0xf6, 0x08, 0xff, 
  0xf2, 0x0b, 0x28, 0x00, 0x0c, 0x00, 0x00, 0xff, 
  0xf2, 0x01, 0x18, 0x00, 0x44, 0x1a, 0x50, 0xff, 
  0xf2, 0x01, 0x1c, 0x00, 0x10, 0x00, 0x00, 0xff, 
  0xf2, 0x80, 0x10, 0x00, 0x00, 0x00, 0x41, 0xff, 
  0xf2, 0x01, 0x10, 0xc7, 0x04, 0x00, 0x08, 0xff, 
  0xf8, 0x00, 0x6c, 0x00, 0x00, 0x81, 0x57, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xbf, 0x00, 0x00, 0x04, 0x00, 0x00, 0x02, 0x2c, 
  0xc0, 0x00, 0x00, 0x10, 0xc0, 0x04, 0x00, 0x00, 
  0xbd, 0x3c, 0x42, 0xc3, 0xbf, 0x00, 0x02, 0xb2, 
  0x00, 0x00, 0x04, 0xee, 0xc0, 0x04, 0x00, 0x00, 
  0x30, 0x00, 0x20, 0x01, 0x80, 0x00, 0x38, 0x98, 
  0x20, 0x10, 0xbf, 0xf2, 0x40, 0x90, 0x30, 0xf8, 
  0x3f, 0xf3, 0xbf, 0xff, 0x38, 0x98, 0x20, 0x74, 
  0xbf, 0xf2, 0x40, 0x90, 0x30, 0x00, 0x20, 0xbf, 
  0x80, 0x40, 0x38, 0x18, 0x20, 0x00, 0xbf, 0xf2, 
  0x40, 0x90, 0x30, 0x00, 0x21, 0x04, 0x80, 0x44, 
  0x38, 0x18, 0x21, 0x04, 0xbf, 0xf2, 0x40, 0x90, 
  0x30, 0x10, 0x2a, 0x55, 0x98, 0x91, 0x38, 0x18, 
  0x21, 0x08, 0xbf, 0xf2, 0x40, 0x90, 0x30, 0xa0, 
  0x29, 0x1e, 0x8f, 0xb8, 0x38, 0x18, 0x21, 0x0c, 
  0xbf, 0xf2, 0x40, 0x90, 0x30, 0x00, 0x30, 0x00, 
  0x81, 0x0c, 0x38, 0x18, 0x21, 0x00, 0xbf, 0xf2, 
  0x40, 0x90, 0x30, 0x00, 0x20, 0x01, 0x80, 0x00, 
  0x38, 0x18, 0x21, 0x60, 0xbf, 0xf2, 0x40, 0x90, 
  0x30, 0x00, 0x34, 0x00, 0x83, 0x40, 0x38, 0x18, 
  0x21, 0x64, 0xbf, 0xf2, 0x40, 0x90, 0x30, 0x00, 
  0x30, 0x00, 0xa4, 0x40, 0x38, 0x18, 0x21, 0x14, 
  0xbf, 0xf2, 0x40, 0x90, 0x30, 0x00, 0x20, 0x00, 
  0x94, 0x50, 0x38, 0x18, 0x21, 0x24, 0xbf, 0xf2, 
  0x40, 0x90, 0x30, 0x50, 0x23, 0x02, 0x80, 0x01, 
  0x38, 0x18, 0x20, 0x80, 0xbf, 0xf2, 0x40, 0x90, 
  0x30, 0x00, 0x20, 0x00, 0x82, 0x00, 0x38, 0x18, 
  0x21, 0x30, 0xbf, 0xf2, 0x40, 0x90, 0x29, 0x03, 
  0x80, 0x0e, 0x38, 0x00, 0x3b, 0x00, 0x80, 0xb7, 
  0x9d, 0x48, 0x90, 0xc0, 0x90, 0xc8, 0x30, 0x10, 
  0x26, 0x00, 0x89, 0x08, 0x38, 0x18, 0x21, 0x70, 
  0xbf, 0xf2, 0x40, 0x90, 0x30, 0xf0, 0x36, 0x08, 
  0x86, 0x45, 0x38, 0x18, 0x21, 0x74, 0xbf, 0xf2, 
  0x40, 0x90, 0x30, 0x00, 0x20, 0x00, 0x80, 0x0c, 
  0x38, 0x18, 0x2b, 0x28, 0xbf, 0xf2, 0x40, 0x90, 
  0x30, 0x00, 0x3a, 0x50, 0x80, 0x44, 0x38, 0x18, 
  0x21, 0x18, 0xbf, 0xf2, 0x40, 0x90, 0x30, 0x00, 
  0x20, 0x00, 0x80, 0x10, 0x38, 0x18, 0x21, 0x1c, 
  0xbf, 0xf2, 0x40, 0x90, 0x30, 0x18, 0x20, 0x08, 
  0x87, 0x04, 0x38, 0x18, 0x21, 0x10, 0xbf, 0xf2, 
  0x40, 0x90, 0x29, 0x03, 0x80, 0x0e, 0x38, 0x20, 
  0x36, 0x00, 0x81, 0x6e, 0x9d, 0x48, 0x90, 0xc0, 
  0x90, 0xc8, 0x38, 0x58, 0x28, 0x00, 0xbf, 0xf2, 
  0x50, 0x90, 0x31, 0x00, 0x20, 0x00, 0x9f, 0xc0, 
  0xdc, 0x01, 0x7c, 0x76, 0x93, 0xc1, 0xcc, 0x40, 
  0x93, 0xd0, 0xc8, 0x70, 0x35, 0x1c, 0x22, 0xa4, 
  0x80, 0x04, 0x37, 0x1c, 0x22, 0x62, 0x80, 0x04, 
  0x39, 0xd8, 0x30, 0x00, 0xbf, 0xfa, 0x51, 0x91, 
  0x32, 0x00, 0x20, 0x80, 0x80, 0x00, 0xdc, 0x9a, 
  0x41, 0x91, 0x39, 0xd8, 0x30, 0x08, 0xbf, 0xfa, 
  0x51, 0x91, 0x32, 0x00, 0x21, 0x31, 0x82, 0x05, 
  0xdc, 0x9a, 0x41, 0x91, 0x39, 0xd8, 0x30, 0x20, 
  0xbf, 0xfa, 0x51, 0x91, 0x32, 0x00, 0x20, 0x80, 
  0x80, 0x00, 0xdc, 0x9a, 0x41, 0x91, 0x39, 0xd8, 
  0x30, 0x28, 0xbf, 0xfa, 0x51, 0x91, 0x32, 0x00, 
  0x21, 0x31, 0x82, 0x03, 0xdc, 0x9a, 0x41, 0x91, 
  0x29, 0x03, 0x80, 0x0e, 0x38, 0x00, 0x3b, 0x00, 
  0x80, 0xb7, 0x9d, 0x48, 0x90, 0xc0, 0x90, 0xc8, 
  0x39, 0xd8, 0x30, 0x00, 0xbf, 0xfa, 0x51, 0x91, 
  0x32, 0xf8, 0x3f, 0x7f, 0xbf, 0xff, 0xdc, 0x82, 
  0x41, 0x91, 0x39, 0xd8, 0x30, 0x00, 0xbf, 0xfa, 
  0x51, 0x91, 0x32, 0xf8, 0x3f, 0xbf, 0xbf, 0xff, 
  0xdc, 0x82, 0x41, 0x91, 0x39, 0xd8, 0x30, 0x20, 
  0xbf, 0xfa, 0x51, 0x91, 0x32, 0xf8, 0x3f, 0x7f, 
  0xbf, 0xff, 0xdc, 0x82, 0x41, 0x91, 0x39, 0xd8, 
  0x30, 0x20, 0xbf, 0xfa, 0x51, 0x91, 0x32, 0xf8, 
  0x3f, 0xbf, 0xbf, 0xff, 0xdc, 0x82, 0x41, 0x91, 
  0x39, 0x98, 0x20, 0x0c, 0xbf, 0xf2, 0x51, 0x91, 
  0x32, 0x00, 0x20, 0x80, 0x80, 0x00, 0xdc, 0x82, 
  0x70, 0xea, 0x96, 0xc3, 0x39, 0xd8, 0x30, 0x00, 
  0xbf, 0xfa, 0x92, 0xc3, 0x51, 0x91, 0x96, 0xc3, 
  0x32, 0x10, 0x20, 0x00, 0x88, 0x00, 0x92, 0xc3, 
  0xdc, 0x9a, 0x92, 0xc3, 0x41, 0x91, 0x39, 0x98, 
  0x20, 0x0c, 0xbf, 0xf2, 0x51, 0x91, 0x32, 0x00, 
  0x28, 0x00, 0x80, 0x00, 0xdc, 0x82, 0x70, 0xea, 
  0x96, 0xc3, 0x39, 0xd8, 0x30, 0x20, 0xbf, 0xfa, 
  0x92, 0xc3, 0x51, 0x91, 0x96, 0xc3, 0x32, 0x10, 
  0x20, 0x00, 0x88, 0x00, 0x92, 0xc3, 0xdc, 0x9a, 
  0x92, 0xc3, 0x41, 0x91, 0x29, 0x03, 0x80, 0x0e, 
  0x38, 0x00, 0x2e, 0x00, 0x87, 0x27, 0x9d, 0x48, 
  0x90, 0xc0, 0x90, 0xc8, 0x31, 0x1c, 0x21, 0x2a, 
  0x80, 0x04, 0x39, 0x98, 0x20, 0x0c, 0xbf, 0xf2, 
  0x51, 0x91, 0x32, 0x00, 0x20, 0x80, 0x80, 0x00, 
  0xdc, 0x82, 0x70, 0xea, 0x35, 0x1c, 0x22, 0xa4, 
  0x80, 0x04, 0x39, 0xd8, 0x30, 0x90, 0xbf, 0xfa, 
  0x51, 0x91, 0x32, 0x80, 0x20, 0x00, 0x80, 0x00, 
  0xdc, 0x9a, 0x41, 0x91, 0x39, 0x98, 0x20, 0x0c, 
  0xbf, 0xf2, 0x51, 0x91, 0x32, 0x00, 0x20, 0x80, 
  0x80, 0x00, 0xdc, 0x82, 0x70, 0xea, 0x37, 0x1c, 
  0x21, 0x50, 0x80, 0x04, 0x9f, 0x7a, 0x90, 0xc0, 
  0x90, 0xc0, 0x9f, 0x71, 0x90, 0xc0, 0x90, 0xc0, 
  0x90, 0xc0, 0x3d, 0xd5, 0xc2, 0x2a, 0x3f, 0x00, 
  0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

uint8_t config_dsp2_arr[]=
{
  0xaa, 0x55, 0xaa, 0xff, 0xff, 0xff, 0x07, 0x43, 
  0x00, 0x00, 0xff, 0xff, 0xff, 0x01, 0x86, 0x06, 
  0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 
  0xf2, 0x80, 0x10, 0x00, 0x00, 0x00, 0x01, 0xff, 
  0xf2, 0x00, 0x00, 0x00, 0x40, 0x00, 0xbf, 0xff, 
  0xf2, 0x01, 0x04, 0x00, 0x44, 0x01, 0x04, 0xff, 
  0xf2, 0x01, 0x08, 0x98, 0x91, 0x0a, 0x55, 0xff, 
  0xf2, 0x01, 0x0c, 0x0f, 0xb8, 0xa9, 0x1e, 0xff, 
  0xf2, 0x01, 0x00, 0x01, 0x0c, 0x10, 0x00, 0xff, 
  0xf2, 0x01, 0x60, 0x00, 0x00, 0x00, 0x01, 0xff, 
  0xf2, 0x01, 0x64, 0x03, 0x40, 0x14, 0x00, 0xff, 
  0xf2, 0x01, 0x14, 0x24, 0x40, 0x10, 0x00, 0xff, 
  0xf2, 0x01, 0x24, 0x14, 0x50, 0x00, 0x00, 0xff, 
  0xf2, 0x00, 0x80, 0x80, 0x01, 0x43, 0x02, 0xff, 
  0xf2, 0x01, 0x30, 0x02, 0x00, 0x00, 0x00, 0xff, 
  0xf2, 0x01, 0x70, 0x89, 0x08, 0x06, 0x00, 0xff, 
  0xf2, 0x01, 0x74, 0x86, 0x45, 0xf6, 0x08, 0xff, 
  0xf2, 0x0b, 0x28, 0x00, 0x0c, 0x00, 0x00, 0xff, 
  0xf2, 0x01, 0x18, 0x00, 0x44, 0x1a, 0x50, 0xff, 
  0xf2, 0x01, 0x1c, 0x00, 0x10, 0x00, 0x00, 0xff, 
  0xf2, 0x80, 0x10, 0x00, 0x00, 0x00, 0x41, 0xff, 
  0xf2, 0x01, 0x10, 0xc7, 0x04, 0x00, 0x08, 0xff, 
  0xf8, 0x00, 0x6c, 0x00, 0x00, 0x81, 0x57, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xbf, 0x00, 0x00, 0x04, 0x00, 0x00, 0x02, 0x2c, 
  0xc0, 0x00, 0x00, 0x10, 0xc0, 0x04, 0x00, 0x00, 
  0xbd, 0x3c, 0x42, 0xc3, 0xbf, 0x00, 0x02, 0xb2, 
  0x00, 0x00, 0x04, 0xee, 0xc0, 0x04, 0x00, 0x00, 
  0x30, 0x00, 0x20, 0x01, 0x80, 0x00, 0x38, 0x98, 
  0x20, 0x10, 0xbf, 0xf2, 0x40, 0x90, 0x30, 0xf8, 
  0x3f, 0xf3, 0xbf, 0xff, 0x38, 0x98, 0x20, 0x74, 
  0xbf, 0xf2, 0x40, 0x90, 0x30, 0x00, 0x20, 0xbf, 
  0x80, 0x40, 0x38, 0x18, 0x20, 0x00, 0xbf, 0xf2, 
  0x40, 0x90, 0x30, 0x00, 0x21, 0x04, 0x80, 0x44, 
  0x38, 0x18, 0x21, 0x04, 0xbf, 0xf2, 0x40, 0x90, 
  0x30, 0x10, 0x2a, 0x55, 0x98, 0x91, 0x38, 0x18, 
  0x21, 0x08, 0xbf, 0xf2, 0x40, 0x90, 0x30, 0xa0, 
  0x29, 0x1e, 0x8f, 0xb8, 0x38, 0x18, 0x21, 0x0c, 
  0xbf, 0xf2, 0x40, 0x90, 0x30, 0x00, 0x30, 0x00, 
  0x81, 0x0c, 0x38, 0x18, 0x21, 0x00, 0xbf, 0xf2, 
  0x40, 0x90, 0x30, 0x00, 0x20, 0x01, 0x80, 0x00, 
  0x38, 0x18, 0x21, 0x60, 0xbf, 0xf2, 0x40, 0x90, 
  0x30, 0x00, 0x34, 0x00, 0x83, 0x40, 0x38, 0x18, 
  0x21, 0x64, 0xbf, 0xf2, 0x40, 0x90, 0x30, 0x00, 
  0x30, 0x00, 0xa4, 0x40, 0x38, 0x18, 0x21, 0x14, 
  0xbf, 0xf2, 0x40, 0x90, 0x30, 0x00, 0x20, 0x00, 
  0x94, 0x50, 0x38, 0x18, 0x21, 0x24, 0xbf, 0xf2, 
  0x40, 0x90, 0x30, 0x50, 0x23, 0x02, 0x80, 0x01, 
  0x38, 0x18, 0x20, 0x80, 0xbf, 0xf2, 0x40, 0x90, 
  0x30, 0x00, 0x20, 0x00, 0x82, 0x00, 0x38, 0x18, 
  0x21, 0x30, 0xbf, 0xf2, 0x40, 0x90, 0x29, 0x03, 
  0x80, 0x0e, 0x38, 0x00, 0x3b, 0x00, 0x80, 0xb7, 
  0x9d, 0x48, 0x90, 0xc0, 0x90, 0xc8, 0x30, 0x10, 
  0x26, 0x00, 0x89, 0x08, 0x38, 0x18, 0x21, 0x70, 
  0xbf, 0xf2, 0x40, 0x90, 0x30, 0xf0, 0x36, 0x08, 
  0x86, 0x45, 0x38, 0x18, 0x21, 0x74, 0xbf, 0xf2, 
  0x40, 0x90, 0x30, 0x00, 0x20, 0x00, 0x80, 0x0c, 
  0x38, 0x18, 0x2b, 0x28, 0xbf, 0xf2, 0x40, 0x90, 
  0x30, 0x00, 0x3a, 0x50, 0x80, 0x44, 0x38, 0x18, 
  0x21, 0x18, 0xbf, 0xf2, 0x40, 0x90, 0x30, 0x00, 
  0x20, 0x00, 0x80, 0x10, 0x38, 0x18, 0x21, 0x1c, 
  0xbf, 0xf2, 0x40, 0x90, 0x30, 0x18, 0x20, 0x08, 
  0x87, 0x04, 0x38, 0x18, 0x21, 0x10, 0xbf, 0xf2, 
  0x40, 0x90, 0x29, 0x03, 0x80, 0x0e, 0x38, 0x20, 
  0x36, 0x00, 0x81, 0x6e, 0x9d, 0x48, 0x90, 0xc0, 
  0x90, 0xc8, 0x38, 0x58, 0x28, 0x00, 0xbf, 0xf2, 
  0x50, 0x90, 0x31, 0x00, 0x20, 0x00, 0x9f, 0xc0, 
  0xdc, 0x01, 0x7c, 0x76, 0x93, 0xc1, 0xcc, 0x40, 
  0x93, 0xd0, 0xc8, 0x70, 0x35, 0x1c, 0x22, 0xa4, 
  0x80, 0x04, 0x37, 0x1c, 0x22, 0x62, 0x80, 0x04, 
  0x39, 0xd8, 0x30, 0x00, 0xbf, 0xfa, 0x51, 0x91, 
  0x32, 0x00, 0x20, 0x80, 0x80, 0x00, 0xdc, 0x9a, 
  0x41, 0x91, 0x39, 0xd8, 0x30, 0x08, 0xbf, 0xfa, 
  0x51, 0x91, 0x32, 0x00, 0x21, 0x31, 0x82, 0x05, 
  0xdc, 0x9a, 0x41, 0x91, 0x39, 0xd8, 0x30, 0x20, 
  0xbf, 0xfa, 0x51, 0x91, 0x32, 0x00, 0x20, 0x80, 
  0x80, 0x00, 0xdc, 0x9a, 0x41, 0x91, 0x39, 0xd8, 
  0x30, 0x28, 0xbf, 0xfa, 0x51, 0x91, 0x32, 0x00, 
  0x21, 0x31, 0x82, 0x03, 0xdc, 0x9a, 0x41, 0x91, 
  0x29, 0x03, 0x80, 0x0e, 0x38, 0x00, 0x3b, 0x00, 
  0x80, 0xb7, 0x9d, 0x48, 0x90, 0xc0, 0x90, 0xc8, 
  0x39, 0xd8, 0x30, 0x00, 0xbf, 0xfa, 0x51, 0x91, 
  0x32, 0xf8, 0x3f, 0x7f, 0xbf, 0xff, 0xdc, 0x82, 
  0x41, 0x91, 0x39, 0xd8, 0x30, 0x00, 0xbf, 0xfa, 
  0x51, 0x91, 0x32, 0xf8, 0x3f, 0xbf, 0xbf, 0xff, 
  0xdc, 0x82, 0x41, 0x91, 0x39, 0xd8, 0x30, 0x20, 
  0xbf, 0xfa, 0x51, 0x91, 0x32, 0xf8, 0x3f, 0x7f, 
  0xbf, 0xff, 0xdc, 0x82, 0x41, 0x91, 0x39, 0xd8, 
  0x30, 0x20, 0xbf, 0xfa, 0x51, 0x91, 0x32, 0xf8, 
  0x3f, 0xbf, 0xbf, 0xff, 0xdc, 0x82, 0x41, 0x91, 
  0x39, 0x98, 0x20, 0x0c, 0xbf, 0xf2, 0x51, 0x91, 
  0x32, 0x00, 0x20, 0x80, 0x80, 0x00, 0xdc, 0x82, 
  0x70, 0xea, 0x96, 0xc3, 0x39, 0xd8, 0x30, 0x00, 
  0xbf, 0xfa, 0x92, 0xc3, 0x51, 0x91, 0x96, 0xc3, 
  0x32, 0x10, 0x20, 0x00, 0x88, 0x00, 0x92, 0xc3, 
  0xdc, 0x9a, 0x92, 0xc3, 0x41, 0x91, 0x39, 0x98, 
  0x20, 0x0c, 0xbf, 0xf2, 0x51, 0x91, 0x32, 0x00, 
  0x28, 0x00, 0x80, 0x00, 0xdc, 0x82, 0x70, 0xea, 
  0x96, 0xc3, 0x39, 0xd8, 0x30, 0x20, 0xbf, 0xfa, 
  0x92, 0xc3, 0x51, 0x91, 0x96, 0xc3, 0x32, 0x10, 
  0x20, 0x00, 0x88, 0x00, 0x92, 0xc3, 0xdc, 0x9a, 
  0x92, 0xc3, 0x41, 0x91, 0x29, 0x03, 0x80, 0x0e, 
  0x38, 0x00, 0x2e, 0x00, 0x87, 0x27, 0x9d, 0x48, 
  0x90, 0xc0, 0x90, 0xc8, 0x31, 0x1c, 0x21, 0x2a, 
  0x80, 0x04, 0x39, 0x98, 0x20, 0x0c, 0xbf, 0xf2, 
  0x51, 0x91, 0x32, 0x00, 0x20, 0x80, 0x80, 0x00, 
  0xdc, 0x82, 0x70, 0xea, 0x35, 0x1c, 0x22, 0xa4, 
  0x80, 0x04, 0x39, 0xd8, 0x30, 0x90, 0xbf, 0xfa, 
  0x51, 0x91, 0x32, 0x80, 0x20, 0x00, 0x80, 0x00, 
  0xdc, 0x9a, 0x41, 0x91, 0x39, 0x98, 0x20, 0x0c, 
  0xbf, 0xf2, 0x51, 0x91, 0x32, 0x00, 0x20, 0x80, 
  0x80, 0x00, 0xdc, 0x82, 0x70, 0xea, 0x37, 0x1c, 
  0x21, 0x50, 0x80, 0x04, 0x9f, 0x7a, 0x90, 0xc0, 
  0x90, 0xc0, 0x9f, 0x71, 0x90, 0xc0, 0x90, 0xc0, 
  0x90, 0xc0, 0x3d, 0xd5, 0xc2, 0x2a, 0x3f, 0x00, 
  0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

#define		DSP_EEPROM_ADDR (0x50)

static char* to_lower(char* s){
	char* r = s;
	char c;
	while (*s != '\0'){
		c = *s;
		if(c >= 'A' && c <= 'Z'){
			*s = c + 0x20;
		}
		s++;
	}
	return r;
}
static void edpu_dsp_select(uint32_t dsp_id){
	if (dsp_id == 0)
		i2c_set_bus_num(2); /*pca9548a channel 1 */
	else
		i2c_set_bus_num(3); /*pca9548a channel 2 */

/*
	ZynqMP> i2c bus
	Bus 0:	zynq_1
	Bus 1:	zynq_1->PCA9548@0x70:0 (PS-PMBUS)
	Bus 2:	zynq_1->PCA9548@0x70:1 (DSP1-EEPROM) --!!
	Bus 3:	zynq_1->PCA9548@0x70:2 (DSP2-EEPROM) --!!
	Bus 4:	zynq_1->PCA9548@0x70:3 (ADT75)
	Bus 5:	zynq_1->PCA9548@0x70:4 (PS-DDR4 SPD)
	Bus 6:	zynq_1->PCA9548@0x70:5 (PL-DDR4 SPD)
	Bus 7:	zynq_1->PCA9548@0x70:6 (PS-USB-SDA)
	Bus 8:	zynq_1->PCA9548@0x70:7 (QSFP+)
*/

	i2c_init(100000, DSP_EEPROM_ADDR); /* eeprom address is 0x50 */
}

static bool edpu_dsp_need_config(uint32_t dsp_id){
	static uint8_t buf[sizeof(config_dsp1_arr)] = {0};
	int i;
	uint8_t *p;
	int ret;
	
	edpu_dsp_select(dsp_id);

	ret = eeprom_read(DSP_EEPROM_ADDR, 0, buf, sizeof(buf));
	if(ret != 0){
		printf("error in eeprom_read, dsp_id=%d\n", dsp_id);
		return 0;
	}

	if(dsp_id == 0)
	  p = config_dsp1_arr;
	else
	  p = config_dsp2_arr;

#if 0
	/* print for debug */
	printf("dsp%d eeprom readback:\n", dsp_id);
	for(i=0; i<sizeof(buf); i++){
	  printf("0x%02x, ", buf[i]);
	  if(i % 8 == 7)
	  	printf("\n");
	}
#endif

	for(i=0; i<sizeof(buf); i++){
		if(p[i] != buf[i]){
		  printf("not match, pos=%d, read=0x%02x, expect=0x%02x\n",i, buf[i], p[i]);
			return 1;
		}
	}
	
	return 0;
}

int edpu_dsp_config_clear(uint32_t dsp_id){
	uint8_t buf[128];
	int i;

	for(i=0; i<sizeof(buf); i++)
		buf[i] = 0;

	edpu_dsp_select(dsp_id);
	for(i=0; i<65536/sizeof(buf); i++){ /* 512K, each write is 128 byte */
		if(0 != eeprom_write(DSP_EEPROM_ADDR, 0, buf, sizeof(buf))){
			printf("clear eeprom error");
			return -EIO;
		}
	}

	return 0;
}
static int edpu_dsp_config(uint32_t dsp_id, uint32_t force){
	uint8_t* p;
	int len;
	int ret;
	
	switch(dsp_id){
		case 0:
			p = config_dsp1_arr;
			len = sizeof(config_dsp1_arr);
			break;
			
		case 1:
			p = config_dsp2_arr;
			len = sizeof(config_dsp2_arr);
			break;
			
		default:
			return -EINVAL;
	}

	if(0 == force){
		if(0 == edpu_dsp_need_config(dsp_id)){
			printf("dsp%d eeprom no need to config\n", dsp_id);
			return 0; 
		}
	}

	printf("configure dsp%d eeprom, data ptr=%p, len=%d\n", dsp_id, p, len);

	edpu_dsp_select(dsp_id);
	ret = eeprom_write(DSP_EEPROM_ADDR, 0, p, len);
	if(ret != 0){
		printf("dsp eeprom_write error %d\n", ret);
		return ret;
	}


	return 0;
}

/*
	ZynqMP> i2c bus
	Bus 0:	zynq_1
	Bus 1:	zynq_1->PCA9548@0x70:0 (PS-PMBUS)
	Bus 2:	zynq_1->PCA9548@0x70:1 (DSP1-EEPROM: 0x50) --!!
	Bus 3:	zynq_1->PCA9548@0x70:2 (DSP2-EEPROM: 0x50) --!!
	Bus 4:	zynq_1->PCA9548@0x70:3 (ADT75: 0x48)
	Bus 5:	zynq_1->PCA9548@0x70:4 (PS-DDR4 SPD)
	Bus 6:	zynq_1->PCA9548@0x70:5 (PL-DDR4 SPD)
	Bus 7:	zynq_1->PCA9548@0x70:6 (PS-USB-SDA)
	Bus 8:	zynq_1->PCA9548@0x70:7 (QSFP+)
*/

static bool edpu_ddr4_select_page(uint8_t page){
	uint8_t dummy;
	int ret;
	
	if(page == 0){
		ret = i2c_write(0x36, 0, 0, &dummy, 1);
	}else{
		ret = i2c_write(0x37, 0, 0, &dummy, 0);
	}
	return ret;
}

static const char* edpu_ddr4_company(uint8_t bank, uint8_t code){
	static char unknown[32];
	if (bank == 1 && code == 0x2c){
		return "Micron Technology";
	}else if (bank == 1 && code == 0xad){
		return "SK Hynix";
	}else if (bank == 2 && code == 0x98){
		return "Kingston";
	}else if(bank == 5 && code == 0xcb){
		return "A-DATA Technology";
	}else if(bank == 3 && code == 0x9E){
		return "Corsair";
	}else if(bank == 8 && code == 0x46){
		return "Gloway International";
	}else if(bank == 9 && code == 0x13){
		return "Gloway International";
	}else if((bank == 0x80 || bank == 0x00 || bank == 0x01) && code == 0xCE){
		return "Samsung";
	}else if(bank == 5 && code == 0xCD){
		return "G.Skill Intl";
	}else if(bank == 10 && code == 0x68){
		return "Kimtigo Semiconductor";
	}else if(bank == 5 && code == 0xef){
		return "Team Group Inc";
	}else if(bank == 6 && code == 0x9b){
		return "Crucial Technology";
	}else if(bank == 9 && code == 0xc8){
		return "Lenovo";
	}else if(bank == 2 && code == 0x7a){
		return "Apacer Technology";
	}
	sprintf(unknown, "Unknown(bank=%d,code=%02x)", bank, code);
	return unknown;
}

static void edpu_ddr4_probe(const char *prefix){
	static uint8_t spd[512];
	char variable[32] = {0};
	char value[32] = {0};
	uint32_t offset;
	
	uint32_t rank;
	uint32_t cap;
	uint32_t bus_width;
	uint32_t sdram_width;
	uint32_t total_memory;

	int8_t tckmin_mtb;
	int8_t tckmin_offset_ftb;
	float tckavg_min_result;
	float speed;

	/* read all page 0 contents */
	if(edpu_ddr4_select_page(0) != 0){
		printf("%s: None!\n", prefix);
		return;
	}
	for(offset=0; offset<256; offset+=32){
		i2c_read(0x51, 			/* chip address */
				offset, 				/* byte address */
				1, 							/* address length */
				&spd[offset], 	/* buffer */
				32); 						/* read length */
	}

	/* read all page 1 contents */
	if(edpu_ddr4_select_page(1) != 0){
		printf("%s: error!\n", prefix);
		return;
	}
	for(offset=0; offset<256; offset+=32){
		i2c_read(0x51,			/* chip address */
				offset, 				/* byte address */
				1,							/* address length */
				&spd[256+offset],/* buffer, have offset */
				32);						/* read length */
	}

	/* parse SPD content */
	if(spd[0x02] != 0x0c){
		printf("%s-DDR is not DDR4, except 0x0c, got 0x%x\n", prefix, spd[0x02]);
		return;
	}
	if(spd[0x03] != 0x03){
		printf("%s-DDR is not SO-DIMM, except 0x03, got 0x%x\n", prefix, spd[0x03]);
		return;
	}
	if(spd[0x06] != 0x00){
		printf("%s-DDR is unknown package type, except 0x00, got 0x%x\n", prefix, spd[0x06]);
		return;
	}

	printf("%s: %s, ", prefix, edpu_ddr4_company((spd[0x140] & 0x7f)+1, spd[0x141]));
	//printf("ID CODE:%02x%02x => bank%d, code:%02x\n", spd[0x140], spd[0x141],  (spd[0x140] & 0x7f)+1, spd[0x141]);

	// calc speed
	//Tckavg_min Result = Tck_min MTB(reg0x12) + Tck_min Offset FTB(reg0x7d)
	tckmin_mtb = (int8_t)spd[0x12];
	tckmin_offset_ftb = (int8_t)spd[0x7d];
	tckavg_min_result = tckmin_mtb*0.125 + tckmin_offset_ftb*0.001;
	speed = (2.0* (1/tckavg_min_result))*1000.0;

	// calc capcatity
	rank = ((spd[0x0c] & 0b111000) >> 3) + 1; /* 1 2 3 4 */
	bus_width = (spd[0x0d] & 0b111); 
	bus_width = 8 << bus_width; /* 8 16 32 64*/
	sdram_width = (spd[0x0c] & 0b111);
	sdram_width = 4 << sdram_width; /* 4 8 16 32 */
	cap = (spd[0x04] & 0b1111);
	cap = 256 << cap;
	/*  Total = SDRAM Capacity / 8 * Primary Bus Width / SDRAM Widht * Logical Ranks per DIMM */
	//total_memory = cap / 8 * bus_width / sdram_width * rank;
	total_memory = (cap * bus_width * rank) / (8*sdram_width);
	
	printf("%4dMB-%dMHz, Rank %d, Bus width %d, SDRAM width %d, SDRAM capcatity %dMb, ", 
			total_memory, (uint32_t)speed, rank, bus_width, sdram_width, cap);

	memcpy(value, &spd[0x149], 20);
	printf("PN:%s\n", value);

	/* export variable */
	sprintf(variable, "ddr_%s_size", prefix);
	sprintf(value, "%d", total_memory);
	env_set(to_lower(variable), value);

	sprintf(variable, "ddr_%s_rank", prefix);
	sprintf(value, "%d", rank);
	env_set(to_lower(variable), value);

	sprintf(variable, "ddr_%s_speed", prefix);
	sprintf(value, "%d", (uint32_t)speed);
	env_set(to_lower(variable), value);
}

static void edpu_ddr4_init(void){
	printf("\nMemory:\n");

	/* PS-DDR4 */
	i2c_set_bus_num(5); /*pca9548a channel 4 */
	i2c_init(100000, 0x51);
	edpu_ddr4_probe("PS");

	/* PL-DDR4 */
	i2c_set_bus_num(6); /*pca9548a channel 5 */
	edpu_ddr4_probe("PL");
}

static int edpu_spi_xfer(uint32_t dout, uint32_t *din)
{
	unsigned int bus = 1;
	unsigned int cs = 0;
	unsigned int mode = SPI_MODE_0;
#ifdef CONFIG_DM_SPI
		char name[30], *str;
		struct udevice *dev;
#endif
	struct spi_slave *slave;
	int ret = 0;

#ifdef CONFIG_DM_SPI
	snprintf(name, sizeof(name), "generic_%d:%d", bus, cs);
	str = strdup(name);
	if (!str)
		return -ENOMEM;
	ret = spi_get_bus_and_cs(bus, cs, 1000000, mode, "spi_generic_drv",
				 str, &dev, &slave);
	if (ret)
		return ret;
#else
	slave = spi_setup_slave(bus, cs, 1000000, mode);
	if (!slave) {
		printf("Invalid device %d:%d\n", bus, cs);
		return -EINVAL;
	}
#endif

	ret = spi_claim_bus(slave);
	if (ret)
		goto done;

	ret = spi_xfer(slave, 32, &dout, din,
					 SPI_XFER_BEGIN | SPI_XFER_END);

#ifndef CONFIG_DM_SPI
		/* We don't get an error code in this case */
		if (ret)
			ret = -EIO;
#endif
		if (ret) {
			printf("Error %d during SPI transaction\n", ret);
		}
	done:
		spi_release_bus(slave);
#ifndef CONFIG_DM_SPI
		spi_free_slave(slave);
#endif

	return ret;
}

int edpu_cpld_write(uint32_t addr, uint32_t data)
{
	uint32_t data_in;
	uint32_t data_out;

	udelay(1000);

	//printf("edpu_cpld_write(0x%04x, 0x%06x)\n", addr, data);
	
	data_out = (addr << 24) | data;
	data_out = htonl(data_out);

	return edpu_spi_xfer(data_out, &data_in);
}

uint32_t edpu_cpld_read(uint32_t addr)
{
	uint32_t data_in;
	uint32_t data_out;
	int ret;
	uint32_t r;

	udelay(1000);

	data_out = (1 << 31) | (addr << 24);
	data_out = htonl(data_out);

	ret = edpu_spi_xfer(data_out, &data_in);

	if(ret){
		printf("edpu_cpld_read error:%d\n", ret);
	}

	r = ntohl(data_in) & 0xffffff;
	//printf("edpu_cpld_read(0x%06x) = 0x%04x)\n", addr, r);
	return r;
}

char* edpu_cpld_version(void){
	static char cpld_ver[32];

	sprintf(cpld_ver, "%x%04x-%x", edpu_cpld_read(T6290_EDPU_REG_VER_YEAR_c),
		edpu_cpld_read(T6290_EDPU_REG_VER_MMDD_c),
		edpu_cpld_read(T6290_EDPU_REG_HW_VER_c));
	return cpld_ver;
}

void edpu_cpld_get_hardware_resources(uint32_t* rf_channels, uint32_t* rf_ports, uint32_t* dsp_bitmap){
	char buf[32];
	uint32_t reg = edpu_cpld_read(T6290_EDPU_REG_HW_RESOURCES_c);

	*rf_channels = (reg & 0x000f);
	*rf_ports    = (reg & 0x00f0) >> 4;
	*dsp_bitmap  = (reg & 0x0f00) >> 8;

	*rf_ports = *rf_ports + 1; /* 0~15 to 1~16 */

	printf("DSP bitmap:0x%x, RF channels:%d, RF ports:%d\n", 
			*dsp_bitmap, *rf_channels, *rf_ports);

	/* rf channel */
	sprintf(buf, "%d", *rf_channels);
	env_set("rfch", buf);

	/* rf port */
	sprintf(buf, "%d", *rf_ports);
	env_set("rfport", buf);

	/* dsp */
	sprintf(buf, "%x", *dsp_bitmap);
	env_set("dsp", buf);

	/* dsp */
	sprintf(buf, "rfc%drfp%d", *rf_channels, *rf_ports);
	env_set("hwcfg", buf);
}

static void edpu_module_reset(uint32_t en, uint32_t bits){
	uint32_t r;

	r = edpu_cpld_read(T6290_EDPU_REG_MODULE_RESET_c);

	if(en)
		r = r | bits;
	else
		r = r & ~bits;

	edpu_cpld_write(T6290_EDPU_REG_MODULE_RESET_c, r);
}

void board_poweroff(void){
	edpu_cpld_write(T6290_EDPU_REG_POWER_OFF_c, 0x7ff);
}

void board_reset(void){
	edpu_cpld_write(T6290_EDPU_REG_SYS_RESTART_c, 0x7ff);
}

#define EDPU_CPLD_FLASH_CMD_SHIFT (16)
#define EDPU_CPLD_FLASH_READ     (0b000)
#define EDPU_CPLD_FLASH_WRITE    (0b010)
#define EDPU_CPLD_FLASH_ENABLE   (0b100)
#define EDPU_CPLD_FLASH_DISABLE  (0b101)
#define EDPU_CPLD_FLASH_ERASE    (0b111)
#define EDPU_CPLD_FLASH_TRACEID  (0b110)

#define EDPU_CPLD_FLASH_PAGE_INSTRU_SN  (6)
#define EDPU_CPLD_FLASH_PAGE_BOARD_SN   (7)
#define EDPU_CPLD_FLASH_PAGE_MAC_PS     (10)
#define EDPU_CPLD_FLASH_PAGE_MAC_DSP    (11)

static int edpu_cpld_flash_ready(void){
	uint32_t i,r;
	
	/* waiting for done */
	i = 1000;
	do{
		udelay(10*1000);
		r = edpu_cpld_read(T6290_EDPU_REG_UFM_RD_STATUS_c);
		if ((r & 0x01) == 0)
			break;
	}while(i-->0);

	/* check */
	if ((r & 0x01) == 0)
		return 0;
	else
		return -EBUSY;
}

static int edpu_cpld_flash_enable(uint32_t en){

	if(0 != edpu_cpld_flash_ready())
		return -EIO;

	if(en)
		edpu_cpld_write(T6290_EDPU_REG_UFM_CMD_c, (EDPU_CPLD_FLASH_ENABLE << EDPU_CPLD_FLASH_CMD_SHIFT));
	else
		edpu_cpld_write(T6290_EDPU_REG_UFM_CMD_c, (EDPU_CPLD_FLASH_DISABLE << EDPU_CPLD_FLASH_CMD_SHIFT));

	if(0 != edpu_cpld_flash_ready())
		return -EIO;
	else
		return 0;
}

int edpu_cpld_flash_write(uint16_t page_addr, uint16_t* p){
	uint32_t i;
	uint32_t data; 

	if(p == 0)
		return -EINVAL;

	/* enable flash */
	if(0 != edpu_cpld_flash_enable(1))
		return -EIO;

	/* load data */
	for (i=0; i<8; i++){
		data = htons(*p); /* to network-order(big-ending) */
		edpu_cpld_write(T6290_EDPU_REG_UFM_WR_DATA_c, data | (i << 16));
		p++;
	}

	/* issue write */
	edpu_cpld_write(T6290_EDPU_REG_UFM_CMD_c, (EDPU_CPLD_FLASH_WRITE << EDPU_CPLD_FLASH_CMD_SHIFT) | (page_addr & 0xfff));

	/* waiting for done */
	if(0 != edpu_cpld_flash_ready())
		return -EIO;

	/* disable flash */
	if(0 != edpu_cpld_flash_enable(0))
		return -EIO;

	return 0;
}

int edpu_cpld_flash_erase(void){

	/* enable flash */
	if(0 != edpu_cpld_flash_enable(1))
		return -EIO;

	/* erase all flash */
	edpu_cpld_write(T6290_EDPU_REG_UFM_CMD_c, (EDPU_CPLD_FLASH_ERASE << EDPU_CPLD_FLASH_CMD_SHIFT));

	/* wait */
	if(0 != edpu_cpld_flash_ready())
		return -EIO;

	/* disable flash */
	if(0 != edpu_cpld_flash_enable(0))
		return -EIO;

	return 0;
}

int edpu_cpld_flash_read(uint32_t page_addr, uint32_t traceid, uint16_t* p){
	int i;
	
	if(p == 0)
		return -EINVAL;

	/* enable flash */
	if(0 != edpu_cpld_flash_enable(1))
		return -EIO;

	/* issue read */
	if(traceid)
		edpu_cpld_write(T6290_EDPU_REG_UFM_CMD_c, (EDPU_CPLD_FLASH_TRACEID << EDPU_CPLD_FLASH_CMD_SHIFT));
	else
		edpu_cpld_write(T6290_EDPU_REG_UFM_CMD_c, (page_addr & 0xfff));

	/* wait */
	if(0 != edpu_cpld_flash_ready())
		return -EIO;

	/* disable flash */
	if(0 != edpu_cpld_flash_enable(0))
		return -EIO;

	/* read the result */
	for(i=0; i<8; i++){
		*p = (edpu_cpld_read(T6290_EDPU_REG_UFM_RD_DATA0_c + i) & 0xffff);
		*p = ntohs(*p);  /* to host order */
		p++;
	}

	return 0;
}

int edpu_cpld_get_ps_mac(uint8_t* mac1, uint8_t* mac2){
	uint16_t buf[8]={0};
	int i;
	
	edpu_cpld_flash_read(EDPU_CPLD_FLASH_PAGE_MAC_PS, 0, buf);
	
	if(buf[0] != 0){
		uint8_t* p = ((uint8_t*)buf)+2;
		for(i=0; i<6; i++){
			*mac1 = *p;
			//printf("%02x:", *mac1);
			mac1++; p++;
		}
		//printf("\n");
		for(i=0; i<6; i++){
			*mac2 = *p;
			//printf("%02x:", *mac2);
			mac2++; p++;
		}
		//printf("\n");
		return 0;
	}
	
	return -EIO;
}

void edpu_init_eth_mac(void){
	static char fmt[] = "%02X:%02X:%02X:%02X:%02X:%02X";
	char ethaddr[20];
	uint8_t mac1[6],mac2[6];
	if (0 == edpu_cpld_get_ps_mac(mac1, mac2)){
		sprintf(ethaddr, fmt,
				mac1[0], mac1[1], mac1[2],
				mac1[3], mac1[4], mac1[5]);
		env_set("ethaddr", ethaddr); /* not eth0addr */

		sprintf(ethaddr, fmt,
				mac2[0], mac2[1], mac2[2],
				mac2[3], mac2[4], mac2[5]);
		env_set("eth1addr", ethaddr);
	}
}

#ifndef rtk_int32
typedef int                     rtk_int32;
#endif

#ifndef rtk_uint32
typedef unsigned int            rtk_uint32;
#endif

struct mii_dev *curr_bus = NULL;
struct phy_device *curr_phydev = NULL;

#define MDC_MDIO_CTRL0_REG          31
#define MDC_MDIO_START_REG          29
#define MDC_MDIO_CTRL1_REG          21
#define MDC_MDIO_ADDRESS_REG        23
#define MDC_MDIO_DATA_WRITE_REG     24
#define MDC_MDIO_DATA_READ_REG      25
#define MDC_MDIO_PREAMBLE_LEN       32

#define MDC_MDIO_START_OP          0xFFFF
#define MDC_MDIO_ADDR_OP           0x000E
#define MDC_MDIO_READ_OP           0x0001
#define MDC_MDIO_WRITE_OP          0x0003

rtk_int32 smi_read(rtk_uint32 mAddrs, rtk_uint32 *rData)
{
	curr_bus->write(curr_bus, 0, 0, MDC_MDIO_CTRL0_REG, MDC_MDIO_ADDR_OP);

	curr_bus->write(curr_bus, 0, 0, MDC_MDIO_ADDRESS_REG, mAddrs);

	curr_bus->write(curr_bus, 0, 0, MDC_MDIO_CTRL1_REG, MDC_MDIO_READ_OP);

	*rData = curr_bus->read(curr_bus, 0, 0, MDC_MDIO_DATA_READ_REG);

	return 0;
}

rtk_int32 smi_write(rtk_uint32 mAddrs, rtk_uint32 rData)
{
	curr_bus->write(curr_bus, 0, 0, MDC_MDIO_CTRL0_REG, MDC_MDIO_ADDR_OP);

	curr_bus->write(curr_bus, 0, 0, MDC_MDIO_ADDRESS_REG, mAddrs);

	curr_bus->write(curr_bus, 0, 0, MDC_MDIO_DATA_WRITE_REG, rData);

	curr_bus->write(curr_bus, 0, 0, MDC_MDIO_CTRL1_REG, MDC_MDIO_WRITE_OP);
	//return -1; //failed
	return 0;
}

static int realtek_switch_init(const char* dev)
{
	rtk_mode_ext_t macMode;
	rtk_api_ret_t rtl_ret;
	rtk_port_mac_ability_t macPortability;
	rtk_data_t txDelay, rxDelay;
	
	if (0 != miiphy_set_current_dev(dev))
		return -1;

	curr_bus = mdio_get_current_dev();

	if (0 != rtk_switch_init())
		return -2;

	memset(&macPortability, 0, sizeof(rtk_port_mac_ability_t));
	rtl_ret = rtk_port_macForceLinkExt_get(EXT_PORT0, &macMode, &macPortability);
	if (rtl_ret != 0)
		return -3;

	macMode = MODE_EXT_RGMII;
	macPortability.forcemode = MAC_FORCE;
	macPortability.speed = SPD_1000M;
	macPortability.link = PORT_LINKUP;
	macPortability.duplex = FULL_DUPLEX;
	macPortability.nway = DISABLED;
	macPortability.txpause = ENABLED;
	macPortability.rxpause = ENABLED;
	rtl_ret = rtk_port_macForceLinkExt_set(EXT_PORT0, macMode, &macPortability);
	if (rtl_ret != 0)
		return -4;

	rtl_ret = rtk_port_rgmiiDelayExt_get(EXT_PORT0, &txDelay, &rxDelay);
	if (rtl_ret != 0)
		return -5;

	/*
		The API is used to set RGMII interface TX and RX delay. In TX delay, the value 1 means delay 2ns and
		0 means no delay. In RX delay, there are 8 steps to tune the delay status.
		*/
	txDelay = 1;
	//txDelay = 0; // can not rx data
	
	//rxDelay = 7;
	//rxDelay = 4; //default
	rtl_ret = rtk_port_rgmiiDelayExt_set(EXT_PORT0, txDelay, rxDelay);
	if (rtl_ret != 0)
		return -6;

	return 0;
}

void edpu_realtek_switch_init(void)
{
	int ret;
	
	printf("\nEthernet Switch1: ");
	ret = realtek_switch_init("eth0");
	if(0 == ret){
		printf("OK\n");
	}else{
		printf("Failed! ret=%d\n", ret);
	}

	printf("Ethernet Switch2: ");
	ret = realtek_switch_init("eth1");
	if(0 == ret){
		printf("OK\n");
	}else{
		printf("Failed! ret=%d\n", ret);
	}
	printf("\n");
}

void edpu_cpld_init(void)
{
	uint32_t rf_channels, rf_ports, dsp_bitmap;

	/* check DDR4 module */
	edpu_ddr4_init();

	/* check CPLD */
	printf("\neDPU CPLD:%s\n", edpu_cpld_version());
	edpu_init_eth_mac(); /* read and set ps ethernet mac address from CPLD*/
	edpu_cpld_get_hardware_resources(&rf_channels, &rf_ports, &dsp_bitmap);

	/* check DSP's I2C EEPROM */
	edpu_module_reset(1, MODULE_RESET_DSP_0 | MODULE_RESET_DSP_1); /* put all dsp into reset */
	udelay(1*1000);

	/* configure dsp i2c eeprom if need */
	//edpu_dsp_config_clear(0);
	if(dsp_bitmap & 0b01){
		printf("checking DSP(a) EEPROM...\n");
		edpu_dsp_config(0, 0);
	}
	if(dsp_bitmap & 0b10){
		printf("checking DSP(b) EEPROM...\n");
		edpu_dsp_config(1, 0);
	}
	printf("\n");
	udelay(10*1000);

	/* release dsp */
	edpu_module_reset(0, MODULE_RESET_DSP_0 | MODULE_RESET_DSP_1);
}
